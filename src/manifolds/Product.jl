#
#      Productmanifold – the manifold generated by the product of manifolds.
#
# Manopt.jl, R. Bergmann, 2018-06-26
import Base: exp, log, show

export Product, ProdPoint, ProdTVector
export distance, dot, exp, log, manifoldDimension, norm, parallelTransport
export zeroTVector
export show, getValue
doc"""
    Product{M<:Manifold} <: Manifold
a product manifold $\mathcal M = \mathcal N_1\times\mathcal N_2\times\cdots\times\mathcal N_m$,
$m\in\mathbb N$,
concatinates a set of manifolds $\mathcal N_i$, $i=1,\ldots,m$, into one using
the sum of the metrics to impose a metric on this manifold. The manifold can
also be an arbitrary Array of manifolds, not necessarily only a vector.
Its abbreviation is `Prod`.
"""
struct Product <: Manifold
  name::String
  manifolds::Array{Manifold}
  abbreviation::String
  Product(mv::Array{Manifold}) = new("Product",
    mv,prod(manifoldDimension.(mv)),string("Prod(",join([m.abbreviation for m in mv],", "),")") )
end
doc"""
    ProdPoint <: MPoint
A point on the [`Product`](@ref) $\mathcal M = \mathcal N_1\times\mathcal N_2\times\cdots\times\mathcal N_m$,$m\in\mathbb N$,
represented by a vector or array of [`MPoint`](@ref)s.
"""
struct ProdPoint <: MPoint
  value::Array{MPoint}
  ProdPoint(v::Array{MPoint}) = new(v)
end
getValue(x::ProdPoint) = x.value
doc"""
    ProdTVector <: TVector
A tangent vector in the product of tangent spaces of the [`Product`](@ref)
$T\mathcal M = T\mathcal N_1\times T\mathcal N_2\times\cdots\times T\mathcal N_m$,$m\in\mathbb N$,
represented by a vector or array of [`TVector`](@ref)s.
"""
struct ProdTVector <: TVector
  value::Array{TVector}
  ProdTVector(value::Array{TVector}) = new(value);
end
getValue(ξ::ProdTVector) = ξ.value
# Functions
# ---
"""
    addNoise(M,x,δ)
computes a vectorized version of addNoise, and returns the noisy [`ProdPoint`](@ref).
"""
addNoise(M::Product, x::ProdPoint,σ) = ProdPoint([addNoise.(M.manifolds, getValue.(x),σ)])
"""
    distance(M,x,y)
computes a vectorized version of distance, and the induced norm from the metric [`dot`](@ref).
"""
distance(M::Product, x::ProdPoint, y::ProdPoint) = sqrt(sum( distance.(M.manifolds, getValue(x), getValue(y) ).^2 ))
"""
    dot(M,x,ξ,ν)
computes the inner product as sum of the component inner products on the [`Product`](@ref).
"""
dot(M::Product, x::ProdPoint, ξ::ProdTVector, ν::ProdTVector) = sum(dot.(M.manifolds, getValue(x), getValue(ξ), getValue(ν) ));
"""
    exp(M,x,ξ)
computes the product exponential map on the [`Prodanifold`](@ref) and returns the corresponding [`ProdPoint`](@ref).
"""
exp(M::Product, x::ProdPoint,ξ::ProdTVector,t::Number=1.0) = ProdPoint( exp.(M.manifolds, getValue(x), getValue(ξ)) )
"""
   log(M,x,y)
computes the product logarithmic map on the [`Prodanifold`](@ref) and returns the corresponding [`ProdTVector`](@ref).
"""
log(M::Product, x::ProdPoint,y::ProdPoint) = ProdTVector(log.(M.manifolds, getValue(x), getValue(y) ))
"""
    manifoldDimension(x)
returns the (product of) dimension(s) of the [`Prodanifold`](@ref) the [`ProdPoint`](@ref)`x` belongs to.
"""
manifoldDimension(x::ProdPoint) =  prod( manifoldDimension.( getValue(x) ) )
"""
    manifoldDimension(M)
returns the (product of) dimension(s) of the [`Prodanifold`](@ref)` M`.
"""
manifoldDimension(M::Product) = prod( manifoldDimension.(M.manifolds) )
"""
    norm(M,x,ξ)
norm of the [`ProdTVector`]` ξ` induced by the metric on the manifold components
of the [`Prodanifold`](@ref)` M`.
"""
norm(M::Product, x::ProdPoint, ξ::ProdTVector) = sqrt( dot(M,x,ξ,ξ) )
"""
    parallelTransport(M,x,ξ)
computes the product parallelTransport map on the [`Prodanifold`](@ref) and returns the corresponding [`ProdTVector`](@ref).
"""
parallelTransport(M::Product, x::ProdPoint, y::ProdPoint, ξ::ProdTVector) = ProdTVector( parallelTransport.(M.manifolds, getValue(x), getValue(y), getValue(ξ)) )
doc"""
    typicalDistance(M)
returns the typical distance on the [`Prod`](@ref)` Prod`, which is the minimum of the internal ones.
"""
typicalDistance(M::Product) = sqrt( length(M.manifolds)*sum( typicalDistance.(M.manifolds).^2 ) );
doc"""
    ξ = zeroTVector(M,x)
returns a zero vector in the tangent space $T_x\mathcal M$ of the
[`ProdPoint`](@ref) $x\in\mathcal M$ on the [`Product`](@ref) manifold `M`.
"""
zeroTVector(M::Product, x::ProdPoint) = ProdTVector( zeroTVector.(M.manifolds, getValue(x) )  );
# Display
show(io::IO, M::Product) = print(io,string("The Product Manifold of [ ",
    join([m.abbreviation for m in M.manifolds])," ]"))
show(io::IO, p::ProdPoint) = print(io,string("Prod[",join(repr.( getValue(p) ),", "),"]"))
show(io::IO, ξ::ProdTVector) = print(io,String("ProdT[", join(repr.(ξ.value),", "),"]"))
